{"version":3,"sources":["herb/core.cljs"],"mappings":";;;;;;;AAQA;;;;;AAAA,AAAMA,AAIHC;AAJH,AAKE,AAAMC,AAAO,AAAA,AAACC,AAA6BF;AAA3C,AACE,AAAI,AAAA,AAACG,AAAEF;AACL,AAAO,AAAA,AAACG,AAAwB,AAAA,AAACC,AAAkCL;;AACnE,AAAA,AAAA,AAACM,AAAOC,AAA8B,AAACC,AAAK,AACN,AAACM;AADKL;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAME;AAAN,AAAAD,AAAAD,AAAA,AAAA,AAAQG;AAAR,AAAYA;;AAAxD,AAA2D,AAAA,AAAUZ,AAE/B,AAAA,AAAcD;;;AAE1D,AAAA;;;;;;AAAA,AAAAe,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAKDI;AALL,AAME,AAAI,AAAA,AAACC,AAA4BD;AAC1BA,AACA,AAACE,AAAOC,AACR,AAAA,AAACC;;AACN,AAAO,AAAA,AAACzB,AAAsD,AAAA,AAACC,AAAkCoB;;;;AAVrG,AAAA,AAAA,AAAMJ;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA;AAAA,AAAA,AAAAA,AAAA,AAAAC,AAAAF;;;AAAA","names":["herb.core/init!","options","parsed","cljs.spec.alpha/conform","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","cljs.spec.alpha/explain-data","cljs.core/reset!","herb.runtime/options","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","p__41733","vec__41734","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","k","v","herb.impl/convert-vendors","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","herb.core/join","seq41737","self__4718__auto__","cljs.core/seq","classes","cljs.spec.alpha.valid_QMARK_.cljs$core$IFn$_invoke$arity$2","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/identity","clojure.string.join.cljs$core$IFn$_invoke$arity$2"],"sourcesContent":["(ns herb.core\n  (:require-macros [herb.core])\n  (:require [herb.impl :as impl]\n            [herb.spec]\n            [clojure.spec.alpha :as s]\n            [clojure.string :as str]\n            [herb.runtime :as runtime]))\n\n(defn init!\n   \"Initialize herb, takes a map of options:\n  :vendors - a vector of vendor prefixes, ie [:webkit :moz]\n  :auto-prefix - A set of CSS properties to auto prefix, ie #{:transition :border-radius} \"\n  [options]\n  (let [parsed (s/conform :herb.spec/options options)]\n    (if (= parsed ::s/invalid)\n      (throw (ex-info \"Invalid input\" (s/explain-data :herb.spec/options options)))\n      (reset! runtime/options {:vendors (-> (mapv (fn [[k v]] v) (:vendors parsed))\n                                            (impl/convert-vendors))\n                               :auto-prefix (:auto-prefix options)}))))\n\n(defn join\n  \"Joins multiple classes together, filtering out nils:\n  ```clojure\n  (join (<class fn-1) (<class fn-2))\n  ```\"\n  [& classes]\n  (if (s/valid? :herb.spec/classes classes)\n    (->> classes\n         (filter identity)\n         (str/join \" \"))\n    (throw (ex-info \"join takes one or more strings as arguments\" (s/explain-data :herb.spec/classes classes)))))\n"]}